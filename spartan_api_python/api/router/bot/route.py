from typing import Any

from fastapi import APIRouter, Query
from starlette.websockets import WebSocket, WebSocketDisconnect

from spartan_api_python.api.router.bot.schema import (
    BotChatResponse,
    BotQuestionRequest,
    BotTrainRequest,
)
from spartan_api_python.core.response.app_response import AppResponse
from spartan_api_python.service.ai.langchain import LangchainManager
from spartan_api_python.service.ai.loader import DataLoader
from spartan_api_python.service.ai.memory import LangchainMemory
from spartan_api_python.settings import logger
from spartan_api_python.utils import find_directories


class BotRouter:
    def __init__(
        self,
        router: APIRouter,
        langchain_memory: LangchainMemory,
        langchain_manager: LangchainManager
    ):
        self.router = router
        self.langchain_memory = langchain_memory
        self.langchain_manager = langchain_manager

        @router.get("/name")
        async def name() -> AppResponse:
            return AppResponse(
                content="ChatGPT",
            )

        @router.post("/question")
        async def get_answer_chatgpt(
            request: BotQuestionRequest
        ) -> AppResponse:
            """
            Get an answer using ChatGPT model based on the provided question.

            :param request: Input data containing the question.
            :return: Answer generated by the ChatGPT model.
            """
            answer_response = await langchain_manager.ask(request.question)
            return AppResponse(
                content=answer_response,
            )

        @router.post("/train-from-text")
        async def train_from_text_knowledge(
            request: BotTrainRequest
        ) -> AppResponse:
            text_encode: list[str] = DataLoader.load_texts(request.input_text)
            langchain_memory.add_texts(text_encode)
            return AppResponse(
                content="Syncing text successfully",
            )

        @router.get("/train-from-dir")
        async def train_from_dir_knowledge(
            folder_name: str = Query(default="train"),
            file_type: str = Query(default="txt"),
        ) -> AppResponse:
            """
            Sync file knowledge txt from default folder train.

            :param folder_name: Name of the folder containing the training files.
            :param file_type: File type of the training files.

            :return: Message of status
            """
            # Send the task to the broker.
            self.pipeline_train_from_dir(folder_name, file_type)
            return AppResponse(
                content="Syncing dir successfully",
            )

        @router.websocket("/chat/{host}")
        async def websocket_endpoint(  # noqa: WPS217, WPS231, WPS213
            websocket: WebSocket,
        ) -> None:
            """
            Websocket chat endpoint for connect ChatGPT.

            :param websocket: Websocket client
            """
            await websocket.accept()
            chat_history: list[tuple[str, Any]] = []
            qa_chain = langchain_manager.conversation(websocket)
            while True:
                try:
                    # Receive and send back the client message
                    question: str = await websocket.receive_text()
                    await websocket.send_json(
                        BotChatResponse(
                            sender="you",
                            message=question,
                            type="stream",
                        ).dict(by_alias=True),
                    )

                    # Construct a response
                    await websocket.send_json(
                        BotChatResponse(sender="bot", message="", type="start").dict(
                            by_alias=True,
                        ),
                    )

                    result = await qa_chain.acall(
                        {"question": question, "chat_history": chat_history},
                    )
                    chat_history.append((question, result["answer"]))

                    await websocket.send_json(
                        BotChatResponse(sender="bot", message="", type="end").dict(by_alias=True),
                    )

                except WebSocketDisconnect:
                    logger.info("websocket disconnect")
                    break

                except Exception as error:
                    logger.error(error)
                    await websocket.send_json(
                        BotChatResponse(
                            sender="bot",
                            message=f"Sorry, We have {error}. Try again.",
                            type="error",
                        ).dict(by_alias=True),
                    )

    def pipeline_train_from_dir(
        self,
        folder_name: str = "train",
        file_type: str = "txt",
    ) -> None:
        """
        Train the pipeline using documents from a directory.

        :param folder_name: Name of the directory containing the training documents.
        :param file_type: File type to filter the training documents.
        :raises Exception: If an error occurs while syncing the files.
        """
        try:
            folder_path = find_directories(folder_name)
            documents = DataLoader.load_documents(folder_path, file_type)
            self.langchain_memory.add_documents(documents)
        except Exception as exc:
            logger.exception(f"{exc}")
            raise exc
